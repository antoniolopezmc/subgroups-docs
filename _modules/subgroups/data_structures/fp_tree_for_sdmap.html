<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>subgroups.data_structures.fp_tree_for_sdmap &mdash; subgroups 0.1.6 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=6e0256f3"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            subgroups
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.html">subgroups package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.algorithms.html">subgroups.algorithms package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.core.html">subgroups.core package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.data_structures.html">subgroups.data_structures package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.quality_measures.html">subgroups.quality_measures package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.tests.html">subgroups.tests package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project_files/subgroups.utils.html">subgroups.utils package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">subgroups</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">subgroups.data_structures.fp_tree_for_sdmap</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for subgroups.data_structures.fp_tree_for_sdmap</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># Contributors:</span>
<span class="c1">#    Antonio López Martínez-Carrasco &lt;antoniolopezmc1995@gmail.com&gt;</span>

<span class="sd">&quot;&quot;&quot;This file contains the implementation of the FPTree data structure used in the SDMap algorithm.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">subgroups.data_structures.fp_tree_node</span> <span class="kn">import</span> <span class="n">FPTreeNode</span>
<span class="kn">from</span> <span class="nn">subgroups.core.selector</span> <span class="kn">import</span> <span class="n">Selector</span>
<span class="kn">from</span> <span class="nn">subgroups.core.operator</span> <span class="kn">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">size</span><span class="p">,</span> <span class="nb">sum</span>
<span class="kn">from</span> <span class="nn">subgroups.exceptions</span> <span class="kn">import</span> <span class="n">InconsistentMethodParametersError</span>

<span class="c1"># Python annotations.</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<div class="viewcode-block" id="FPTreeForSDMap">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap">[docs]</a>
<span class="k">class</span> <span class="nc">FPTreeForSDMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class represents the FPTree data structure used in the SDMap algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_root_node&quot;</span><span class="p">,</span> <span class="s2">&quot;_header_table&quot;</span><span class="p">,</span> <span class="s2">&quot;_sorted_header_table&quot;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># The root of the tree. In this case, in each node, we have two counter: the true positives tp of the selector of the node and the false positives fp of the selector of the node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span> <span class="o">=</span> <span class="n">FPTreeNode</span><span class="p">(</span><span class="n">Selector</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">EQUAL</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># The header table is represented with a python dictionary, in which the key is a selector and the value is a list with 3 elements:</span>
        <span class="c1"># - The first element is a list with 2 elements:</span>
        <span class="c1">#   * The summation of the true positives tp of all the nodes with that selector.</span>
        <span class="c1">#   * The summation of the false positives fp of all the nodes with that selector.</span>
        <span class="c1"># - The second element is a FPTreeNode. It is the FIRST FPTreeNode of the horizontal list (the list with all the FPTreeNode with the same selector).</span>
        <span class="c1"># - The third element is a FPTreeNode. It is the LAST FPTreeNode of the horizontal list (the list with all the FPTreeNode with the same selector).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># IMPORTANT: THIS CRITERION HAS BEEN EXTRACTED FROM THE ORIGINAL IMPLEMENTATION OF THE SDMAP ALGORITHM (IN VIKAMINE).</span>
        <span class="c1"># We have to sort the selectors of the header table according to the summation of &#39;n&#39; (i.e., summation of tp + summation of fp).</span>
        <span class="c1"># - We store them in a list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_header_table</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">_get_root_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FPTreeNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span>
    
    <span class="k">def</span> <span class="nf">_get_header_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Selector</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span>
    
    <span class="k">def</span> <span class="nf">_get_sorted_header_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_header_table</span>
    
    <span class="n">root_node</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_root_node</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;The root of the tree.&quot;</span><span class="p">)</span>
    <span class="n">header_table</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_header_table</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;The header table.&quot;</span><span class="p">)</span>
    <span class="n">sorted_header_table</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_sorted_header_table</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;A list with the selectors of the header table sorted according to the summation of the &#39;n&#39; (summation of the true positives tp + summation of the false positives fp).&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="FPTreeForSDMap.is_empty">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.is_empty">[docs]</a>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to check whether the FPTree only has the root node.</span>
<span class="sd">        </span>
<span class="sd">        :return: whether the FPTree only has the root node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span><span class="o">.</span><span class="n">number_of_children</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="FPTreeForSDMap.there_is_a_single_path">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.there_is_a_single_path">[docs]</a>
    <span class="k">def</span> <span class="nf">there_is_a_single_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to check whether all internal nodes only have 1 child.</span>
<span class="sd">        </span>
<span class="sd">        :return: whether all internal nodes only have 1 child.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Go down while the current node has only one child.</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current_node</span><span class="o">.</span><span class="n">number_of_children</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">current_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">current_node</span><span class="o">.</span><span class="n">_childs</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Get the unique child node.</span>
        <span class="c1"># Check the number of children of the current node.</span>
        <span class="c1"># - If the number of children is 0, we are at the end of the tree and there is a single path.</span>
        <span class="c1"># - If the number of children is greater than 1, there is not a single path.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">current_node</span><span class="o">.</span><span class="n">number_of_children</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="FPTreeForSDMap.tree_as_str">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.tree_as_str">[docs]</a>
    <span class="k">def</span> <span class="nf">tree_as_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to print as str the complete FPTree from the root node.</span>
<span class="sd">        </span>
<span class="sd">        :return: the printed FPTree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span><span class="o">.</span><span class="n">tree_as_str</span><span class="p">(</span><span class="n">current_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="FPTreeForSDMap.header_table_as_str">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.header_table_as_str">[docs]</a>
    <span class="k">def</span> <span class="nf">header_table_as_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">follow_node_links</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to print all the entries of the FPTree header table.</span>
<span class="sd">        </span>
<span class="sd">        :param follow_node_links: whether print all the FPTreeNode ids in the horizontal list or only the first one. By default, True.</span>
<span class="sd">        :return: the printed header table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">follow_node_links</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;follow_node_links&#39; must be &#39;bool&#39;.&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
            <span class="n">current_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="s2">&quot;{selector: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="s2">&quot;summations: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;} -&gt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">follow_node_links</span><span class="p">:</span>
                <span class="n">current_node_in_the_horizontal_list</span> <span class="o">=</span> <span class="n">current_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">current_node_in_the_horizontal_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">current_node_in_the_horizontal_list</span> <span class="o">=</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">node_link</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="s2">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_node_in_the_horizontal_list</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">result</span></div>

    
    <span class="c1"># IMPORTANT: in the original implementation of the SDMap algorithm (in Vikamine), they check &#39;n&#39; (true positives + false positives) in order to prune the frequent selectors. In our implementation, we use two threshold types: (1) the true positives (tp) and the false positives (fp) separately or (2) the subgroup description size (n).</span>
<div class="viewcode-block" id="FPTreeForSDMap.generate_set_of_frequent_selectors">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.generate_set_of_frequent_selectors">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_set_of_frequent_selectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pandas_dataframe</span> <span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">target</span> <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">minimum_tp</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minimum_fp</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minimum_n</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Selector</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to scan the pandas DataFrame in order to generate the set of frequent selectors. Two threshold types could be used: (1) the true positives tp and the false positives fp separately or (2) the subgroup description size n (n = tp + fp). This means that: (1) if &#39;minimum_tp&#39; and &#39;minimum_fp&#39; have a value of type &#39;int&#39;, &#39;minimum_n&#39; must be None; and (2) if &#39;minimum_n&#39; has a value of type &#39;int&#39;, &#39;minimum_tp&#39; and &#39;minimum_fp&#39; must be None. IMPORTANT: missing values are not supported yet.</span>
<span class="sd">        </span>
<span class="sd">        :param pandas_dataframe: the DataFrame which is scanned. IMPORTANT: missing values are not supported yet.</span>
<span class="sd">        :param target: a tuple with 2 elements: the target attribute name and the target value.</span>
<span class="sd">        :param minimum_tp: the minimum true positives (tp) threshold.</span>
<span class="sd">        :param minimum_fp: the minimum false positives (fp) threshold.</span>
<span class="sd">        :param minimum_n: the minimum subgroup description size (n) threshold.</span>
<span class="sd">        :return: a dictionary in which the keys are strings (the concatenation of the selector attribute name and the selector value) and the values are tuples with 3 elements: (1) the selector, (2) a list with 2 elements: the true positives tp of it and the false positives fp of it, and (3) a number indicating the insertion order in this dictionary (starting from 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;pandas_dataframe&#39; must be &#39;DataFrame&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;target&#39; must be &#39;tuple&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minimum_tp</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;minimum_tp&#39; must be &#39;int&#39; or &#39;NoneType&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minimum_fp</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_fp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;minimum_fp&#39; must be &#39;int&#39; or &#39;NoneType&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minimum_n</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;minimum_n&#39; must be &#39;int&#39; or &#39;NoneType&#39;.&quot;</span><span class="p">)</span>
        <span class="c1"># Depending on the values of the parameters &#39;minimum_tp&#39;, &#39;minimum_fp&#39; and &#39;minimum_n&#39; ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minimum_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_fp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Get the target column as a mask: True if the value is equal to the target value and False otherwise.</span>
            <span class="n">target_attribute_as_a_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Result.</span>
            <span class="n">final_dict_of_frequent_selectors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="c1"># Iterate through the columns (except the target).</span>
            <span class="n">insertion_order</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># The insertion order is necessary later in order to sort the elements which have the same &#39;n&#39; in a same row.</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">pandas_dataframe</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">current_Series</span> <span class="o">=</span> <span class="n">pandas_dataframe</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="c1"># Use the &#39;groupby&#39; method in order to obtain, for each value, the true positives tp and the false positives fp.</span>
                <span class="n">tp_and_fp_for_each_value</span> <span class="o">=</span> <span class="n">target_attribute_as_a_mask</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">current_Series</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">([</span><span class="n">size</span><span class="p">,</span> <span class="nb">sum</span><span class="p">])</span> <span class="c1"># tp -&gt; sum; fp -&gt; size - sum; n -&gt; size.</span>
                <span class="c1"># Filter the results according to &#39;minimum_tp&#39; and &#39;minimum_fp&#39;.</span>
                <span class="n">filtered</span> <span class="o">=</span> <span class="n">tp_and_fp_for_each_value</span><span class="p">[(</span><span class="n">tp_and_fp_for_each_value</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minimum_tp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">tp_and_fp_for_each_value</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">tp_and_fp_for_each_value</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">minimum_fp</span><span class="p">)]</span>
                <span class="c1"># The corresponding values are the indexes of the DataFrame &#39;filtered&#39;.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">filtered</span><span class="o">.</span><span class="n">index</span>
                <span class="c1"># We create the selectors and we add them to the final dictionary.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="c1"># IMPORTANT: we use &#39;repr&#39; in order to add simple quotes to the values of type str, but not to the values of numeric types.</span>
                    <span class="n">final_dict_of_frequent_selectors</span><span class="p">[</span><span class="n">column</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Selector</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">EQUAL</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">[</span> <span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;sum&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;sum&quot;</span><span class="p">])</span> <span class="p">],</span> <span class="n">insertion_order</span><span class="p">)</span>
                    <span class="n">insertion_order</span> <span class="o">=</span> <span class="n">insertion_order</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Finally, we return the results.</span>
            <span class="k">return</span> <span class="n">final_dict_of_frequent_selectors</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">minimum_tp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_fp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Get the target column as a mask: True if the value is equal to the target value and False otherwise.</span>
            <span class="n">target_attribute_as_a_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Result.</span>
            <span class="n">final_dict_of_frequent_selectors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="c1"># Iterate through the columns (except the target).</span>
            <span class="n">insertion_order</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># The insertion order is necessary later in order to sort the elements which have the same &#39;n&#39; in a same row.</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">pandas_dataframe</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">current_Series</span> <span class="o">=</span> <span class="n">pandas_dataframe</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="c1"># Use the &#39;groupby&#39; method in order to obtain, for each value, the true positives tp and the false positives fp.</span>
                <span class="n">tp_and_fp_for_each_value</span> <span class="o">=</span> <span class="n">target_attribute_as_a_mask</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">current_Series</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">([</span><span class="n">size</span><span class="p">,</span> <span class="nb">sum</span><span class="p">])</span> <span class="c1"># tp -&gt; sum; fp -&gt; size - sum; n -&gt; size.</span>
                <span class="c1"># Filter the results according to &#39;minimum_tp&#39; and &#39;minimum_fp&#39;.</span>
                <span class="n">filtered</span> <span class="o">=</span> <span class="n">tp_and_fp_for_each_value</span><span class="p">[</span><span class="n">tp_and_fp_for_each_value</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minimum_n</span><span class="p">]</span>
                <span class="c1"># The corresponding values are the indexes of the DataFrame &#39;filtered&#39;.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">filtered</span><span class="o">.</span><span class="n">index</span>
                <span class="c1"># We create the selectors and we add them to the final dictionary.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="c1"># IMPORTANT: we use &#39;repr&#39; in order to add simple quotes to the values of type str, but not to the values of numeric types.</span>
                    <span class="n">final_dict_of_frequent_selectors</span><span class="p">[</span><span class="n">column</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Selector</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">EQUAL</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">[</span> <span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;sum&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;sum&quot;</span><span class="p">])</span> <span class="p">],</span> <span class="n">insertion_order</span><span class="p">)</span>
                    <span class="n">insertion_order</span> <span class="o">=</span> <span class="n">insertion_order</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Finally, we return the results.</span>
            <span class="k">return</span> <span class="n">final_dict_of_frequent_selectors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InconsistentMethodParametersError</span><span class="p">(</span><span class="s2">&quot;If &#39;minimum_tp&#39; and &#39;minimum_fp&#39; have a value of type &#39;int&#39;, &#39;minimum_n&#39; must be None; and if &#39;minimum_n&#39; has a value of type &#39;int&#39;, &#39;minimum_tp&#39; and &#39;minimum_fp&#39; must be None.&quot;</span><span class="p">)</span></div>

    
    <span class="c1"># IMPORTANT: in the original paper, this method is recursive. In our implementation, the method is iterative.</span>
    <span class="k">def</span> <span class="nf">_insert_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_selectors</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Selector</span><span class="p">],</span> <span class="n">parent_node</span> <span class="p">:</span> <span class="n">FPTreeNode</span><span class="p">,</span> <span class="n">target_match</span> <span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private method to insert a list of selectors from a parent node.</span>
<span class="sd">        </span>
<span class="sd">        :param list_of_selectors: the list of selectors which is inserted in the tree. IMPORTANT: we assume that the list of selectors only contains selectors.</span>
<span class="sd">        :param parent_node: the parent node from which to start the insertion.</span>
<span class="sd">        :param target_match: whether we consider that the target attribute match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">parent_node</span>
        <span class="k">for</span> <span class="n">selector</span> <span class="ow">in</span> <span class="n">list_of_selectors</span><span class="p">:</span>
            <span class="c1"># Get the child node with the current selector or None if it does not exist.</span>
            <span class="n">child_node_with_this_selector</span> <span class="o">=</span> <span class="n">current_parent_node</span><span class="o">.</span><span class="n">get_child_by_selector</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
            <span class="c1"># Check if the node exists or not and if the parameter &#39;target_match&#39; is True or False.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target_match</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child_node_with_this_selector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Increase the true positives tp in the node.</span>
                <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">counters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Increase the total number of true positives tp in the header table.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Go down in the tree (the current node will be the current parent node in the next iteration).</span>
                <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span>
            <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">target_match</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child_node_with_this_selector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Increase the false positives fp in the node.</span>
                <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Increase the total number of false positives fp in the header table.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Go down in the tree (the current node will be the current parent node in the next iteration).</span>
                <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">target_match</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child_node_with_this_selector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create a new FPTree Node.</span>
                <span class="n">new_fptreenode</span> <span class="o">=</span> <span class="n">FPTreeNode</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># Add it as a child of the current parent node.</span>
                <span class="n">current_parent_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">new_fptreenode</span><span class="p">)</span>
                <span class="c1"># Check if the current selector is in the header table.</span>
                <span class="k">if</span> <span class="n">selector</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
                    <span class="c1"># If it is in the header table, add the new node at the end of the horizontal list and increase the summation of true positives tp in the header table.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">_node_link</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># If not, create the entry and add it.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">new_fptreenode</span><span class="p">,</span> <span class="n">new_fptreenode</span> <span class="p">]</span>
                <span class="c1"># Go down in the tree (the current node will be the current parent node in the next iteration).</span>
                <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
            <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">target_match</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child_node_with_this_selector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create a new FPTree Node.</span>
                <span class="n">new_fptreenode</span> <span class="o">=</span> <span class="n">FPTreeNode</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># Add it as a child of the current parent node.</span>
                <span class="n">current_parent_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">new_fptreenode</span><span class="p">)</span>
                <span class="c1"># Check if the current selector is in the header table.</span>
                <span class="k">if</span> <span class="n">selector</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
                    <span class="c1"># If it is in the header table, add the new node at the end of the horizontal list and increase the summation of false positives fp in the header table.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">_node_link</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># If not, create the entry and add it.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">new_fptreenode</span><span class="p">,</span> <span class="n">new_fptreenode</span> <span class="p">]</span>
                <span class="c1"># Go down in the tree (the current node will be the current parent node in the next iteration).</span>
                <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
    
<div class="viewcode-block" id="FPTreeForSDMap.build_tree">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.build_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pandas_dataframe</span> <span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">set_of_frequent_selectors</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Selector</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">target</span> <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to build the complete FPTree from a pandas DataFrame and using the set of frequent selectors. IMPORTANT: missing values are not supported yet.</span>
<span class="sd">        </span>
<span class="sd">        :param pandas_dataframe: the DataFrame which is scanned. IMPORTANT: missing values are not supported yet.</span>
<span class="sd">        :param set_of_frequent_selectors: the set of frequent selectors generated by the method &#39;generate_set_of_frequent_selectors&#39;.</span>
<span class="sd">        :param target: a tuple with 2 elements: the target attribute name and the target value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;pandas_dataframe&#39; must be &#39;DataFrame&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">set_of_frequent_selectors</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;set_of_frequent_selectors&#39; must be &#39;dict&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;target&#39; must be &#39;tuple&#39;.&quot;</span><span class="p">)</span>
        <span class="c1"># Iterate through the rows by index.</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pandas_dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">target_value_in_the_current_row</span> <span class="o">=</span> <span class="n">pandas_dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">selectors_in_the_current_row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Iterate through the columns (except the target).</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">pandas_dataframe</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">current_element</span> <span class="o">=</span> <span class="n">pandas_dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span>
                <span class="c1"># Add the corresponding selector from &#39;set_of_frequent_selectors&#39; to &#39;selectors_in_the_current_row&#39;.</span>
                <span class="c1"># ===&gt; IMPORTANT: the selector might not exist because it was pruned. In this case, a KeyError exception is raised.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># IMPORTANT: we use &#39;repr&#39; in order to add simple quotes to the values of type str, but not to the values of numeric types.</span>
                    <span class="n">selectors_in_the_current_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">set_of_frequent_selectors</span><span class="p">[</span><span class="n">column</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">current_element</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span> <span class="c1"># If the exception is raised, we do nothing.</span>
            <span class="c1"># We sort &#39;selectors_in_the_current_row&#39; according to the value of &#39;n&#39; (tp+fp) in the set of frequent selectors (CRITERION EXTRACTED FROM VIKAMINE).</span>
            <span class="c1"># - In case of tie, we NEED TO MAINTAIN the order of the selectors according to the order in the set of frequent selectors. For this reason, it is necessary to sort twice.</span>
            <span class="c1"># IMPORTANT: we use &#39;repr&#39; in order to add simple quotes to the values of type str, but not to the values of numeric types.</span>
            <span class="n">selectors_in_the_current_row</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">selectors_in_the_current_row</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">set_of_frequent_selectors</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">2</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># key -&gt; [2] : the insertion order in the dictionary.</span>
            <span class="n">selectors_in_the_current_row</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">selectors_in_the_current_row</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">set_of_frequent_selectors</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">set_of_frequent_selectors</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># key -&gt; &#39;n&#39; : sum of tp and fp.</span>
            <span class="c1"># Insert.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_tree</span><span class="p">(</span><span class="n">selectors_in_the_current_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span><span class="p">,</span> <span class="p">(</span><span class="n">target_value_in_the_current_row</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Finally, we create the sorted header table.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_header_table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_header_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="c1"># IMPORTANT: THIS CRITERION HAS BEEN EXTRACTED FROM THE ORIGINAL IMPLEMENTATION OF THE SDMAP ALGORITHM (IN VIKAMINE).</span>
        <span class="c1"># We have to sort the selectors according to the summation of &#39;n&#39; (i.e., summation of tp + summation of fp).</span>
        <span class="c1"># - In case of tie, we maintain the insertion order in the dictionary &#39;header_table&#39;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_header_table</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># Ascending order.</span></div>

    
<div class="viewcode-block" id="FPTreeForSDMap.generate_conditional_fp_tree">
<a class="viewcode-back" href="../../../project_files/subgroups.data_structures.html#subgroups.data_structures.fp_tree_for_sdmap.FPTreeForSDMap.generate_conditional_fp_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_conditional_fp_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_selectors</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Selector</span><span class="p">],</span> <span class="n">minimum_tp</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minimum_fp</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minimum_n</span> <span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FPTreeForSDMap&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to get the conditional FPTree with a list of selectors. Two threshold types could be used: (1) the true positives tp and the false positives fp separately or (2) the subgroup description size n (n = tp + fp). This means that: (1) if &#39;minimum_tp&#39; and &#39;minimum_fp&#39; have a value of type &#39;int&#39;, &#39;minimum_n&#39; must be None; and (2) if &#39;minimum_n&#39; has a value of type &#39;int&#39;, &#39;minimum_tp&#39; and &#39;minimum_fp&#39; must be None.</span>
<span class="sd">        </span>
<span class="sd">        :param list_of_selectors: the list of selectors which is used. IMPORTANT: we assume that the list of selectors only contains selectors.</span>
<span class="sd">        :param minimum_tp: the minimum true positives (tp) threshold.</span>
<span class="sd">        :param minimum_fp: the minimum false positives (fp) threshold.</span>
<span class="sd">        :param minimum_n: the minimum subgroup description size (n) threshold.</span>
<span class="sd">        :return: the generated conditional FPTree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">list_of_selectors</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;list_of_selectors&#39; must be &#39;list&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minimum_tp</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;minimum_tp&#39; must be &#39;int&#39; or &#39;NoneType&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minimum_fp</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_fp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;minimum_fp&#39; must be &#39;int&#39; or &#39;NoneType&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minimum_n</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of the parameter &#39;minimum_n&#39; must be &#39;int&#39; or &#39;NoneType&#39;.&quot;</span><span class="p">)</span>
        <span class="c1"># Depending on the values of the parameters &#39;minimum_tp&#39;, &#39;minimum_fp&#39; and &#39;minimum_n&#39; ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minimum_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_fp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">use_tp_and_fp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">minimum_tp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_fp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minimum_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">use_tp_and_fp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InconsistentMethodParametersError</span><span class="p">(</span><span class="s2">&quot;If &#39;minimum_tp&#39; and &#39;minimum_fp&#39; have a value of type &#39;int&#39;, &#39;minimum_n&#39; must be None; and if &#39;minimum_n&#39; has a value of type &#39;int&#39;, &#39;minimum_tp&#39; and &#39;minimum_fp&#39; must be None.&quot;</span><span class="p">)</span>
        <span class="c1"># We only use the first selector in the list in the creation process (the selector at the left side).</span>
        <span class="n">first_selector</span> <span class="o">=</span> <span class="n">list_of_selectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># We initialize the final result.</span>
        <span class="n">final_conditional_fp_tree</span> <span class="o">=</span> <span class="n">FPTreeForSDMap</span><span class="p">()</span>
        <span class="c1">### 1. Generate the conditional pattern base and a dict of frequent selectors with their selectors. ###</span>
        <span class="n">conditional_pattern_base</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list[list[ element 1 -&gt; list[Selector], element 2 -&gt; int, element 3 -&gt; int ]]</span>
        <span class="c1"># If the first selector is not in the header table, return the current conditional FPTree.</span>
        <span class="k">if</span> <span class="n">first_selector</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_conditional_fp_tree</span>
        <span class="c1"># Dictionary with all the frequent selectors (before pruning).</span>
        <span class="n">dict_of_all_frequent_selectors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># dict[str, tuple[Selector, list[int], int]]</span>
        <span class="c1"># Get the first node in the corresponding horizontal list.</span>
        <span class="n">current_node_in_the_horizontal_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">first_selector</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Iterate through the horizontal list.</span>
        <span class="n">insertion_order</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># The insertion order is necessary later in order to sort the elements which have the same &#39;n&#39; in a same path.</span>
        <span class="k">while</span><span class="p">(</span><span class="n">current_node_in_the_horizontal_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Path from the root node to to the current node in the corresponding horizontal list.</span>
            <span class="n">current_path</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Go up in the tree until the root node.</span>
            <span class="n">current_node_in_the_path</span> <span class="o">=</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_parent</span> <span class="c1"># We start from the parent.</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">current_node_in_the_path</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_node</span><span class="p">):</span>
                <span class="n">current_selector</span> <span class="o">=</span> <span class="n">current_node_in_the_path</span><span class="o">.</span><span class="n">_selector</span>
                <span class="c1"># Add the selector to &#39;dict_of_all_frequent_selectors&#39;.</span>
                <span class="c1"># IMPORTANT: the true positives tp and the false positives fp of all the nodes in the path are those of the current node in the horizontal list.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">current_selector</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">current_selector</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">current_selector</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">current_selector</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">current_selector</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">current_selector</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">current_selector</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">current_selector</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c1"># Try to access to the entry and if it does not exist, create a new one.</span>
                    <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">current_selector</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">current_selector</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span> <span class="o">=</span> \
                        <span class="p">(</span><span class="n">current_selector</span><span class="p">,</span> <span class="p">[</span><span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">insertion_order</span><span class="p">)</span>
                    <span class="n">insertion_order</span> <span class="o">=</span> <span class="n">insertion_order</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># IMPORTANT: in this case, the insertion order decreases (we use negative numbers) because, when we create the conditional pattern base, we iterate from the bottom to the top in the FPTree.</span>
                <span class="c1"># Insert the selector at the beginning of the current path.</span>
                <span class="n">current_path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_selector</span><span class="p">)</span>
                <span class="c1"># Go up.</span>
                <span class="n">current_node_in_the_path</span> <span class="o">=</span> <span class="n">current_node_in_the_path</span><span class="o">.</span><span class="n">_parent</span>
            <span class="c1"># If the path is not empty.</span>
            <span class="k">if</span> <span class="n">current_path</span><span class="p">:</span>
                <span class="c1"># Append to &#39;conditional_pattern_base&#39;.</span>
                <span class="n">conditional_pattern_base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span> <span class="n">current_path</span><span class="p">,</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>
            <span class="c1"># Finally, go the the next node in the horizontal list.</span>
            <span class="n">current_node_in_the_horizontal_list</span> <span class="o">=</span> <span class="n">current_node_in_the_horizontal_list</span><span class="o">.</span><span class="n">_node_link</span>
        <span class="c1">### 2. Prune the dict of frequent selectors (depending on the values of the parameters &#39;minimum_tp&#39;, &#39;minimum_fp&#39; and &#39;minimum_n&#39;). ###</span>
        <span class="n">dict_of_frequent_selectors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># dict[str, tuple[Selector, list[int], int]]</span>
        <span class="k">if</span> <span class="n">use_tp_and_fp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_of_all_frequent_selectors</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minimum_tp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minimum_fp</span><span class="p">):</span>
                    <span class="n">dict_of_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_of_all_frequent_selectors</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">minimum_n</span><span class="p">):</span>
                    <span class="n">dict_of_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dict_of_all_frequent_selectors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> 
        <span class="c1">### 3. Insert all the paths of the conditional pattern base in the tree. ###</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">conditional_pattern_base</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tp</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">valid_selectors_in_this_path</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Only the valid selectors after pruning.</span>
            <span class="c1"># Iterate through the selectors in the path.</span>
            <span class="k">for</span> <span class="n">selector</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="c1"># Add the selector to &#39;valid_selectors_in_this_path&#39;.</span>
                <span class="c1"># ===&gt; IMPORTANT: the selector might not exist because it was pruned. In this case, a KeyError exception is raised.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># IMPORTANT: we use &#39;repr&#39; in order to add simple quotes to the values of type str, but not to the values of numeric types.</span>
                    <span class="n">valid_selectors_in_this_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dict_of_frequent_selectors</span><span class="p">[</span><span class="n">selector</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">selector</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span> <span class="c1"># If the exception is raised, we do nothing.</span>
            <span class="c1"># We sort &#39;valid_selectors_in_this_path&#39; according to the value of &#39;n&#39; (tp+fp) in the set of frequent selectors (CRITERION EXTRACTED FROM VIKAMINE).</span>
            <span class="c1"># - In case of tie, we NEED TO MAINTAIN the order of the selectors according to the order in the set of frequent selectors. For this reason, it is necessary to sort twice.</span>
            <span class="c1"># IMPORTANT: we use &#39;repr&#39; in order to add simple quotes to the values of type str, but not to the values of numeric types.</span>
            <span class="n">valid_selectors_in_this_path</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">valid_selectors_in_this_path</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">dict_of_frequent_selectors</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">2</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># key -&gt; [2] : the insertion order in the dictionary.</span>
            <span class="n">valid_selectors_in_this_path</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">valid_selectors_in_this_path</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">dict_of_frequent_selectors</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dict_of_frequent_selectors</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">attribute_name</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># key -&gt; &#39;n&#39; : sum of tp and fp.</span>
            <span class="c1"># Insert.</span>
            <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_insert_in_conditional_fp_tree</span><span class="p">(</span><span class="n">valid_selectors_in_this_path</span><span class="p">,</span> <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_root_node</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
        <span class="c1"># Finally, we create the sorted header table.</span>
        <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_sorted_header_table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
            <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_sorted_header_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="c1"># IMPORTANT: THIS CRITERION HAS BEEN EXTRACTED FROM THE ORIGINAL IMPLEMENTATION OF THE SDMAP ALGORITHM (IN VIKAMINE).</span>
        <span class="c1"># We have to sort the selectors according to the summation of &#39;n&#39; (i.e., summation of tp + summation of fp).</span>
        <span class="c1"># - In case of tie, we maintain the insertion order in the dictionary &#39;header_table&#39;.</span>
        <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_sorted_header_table</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">final_conditional_fp_tree</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># Ascending order.</span>
        <span class="c1"># Return the final conditional FPTree.</span>
        <span class="k">return</span> <span class="n">final_conditional_fp_tree</span></div>

    
    <span class="k">def</span> <span class="nf">_insert_in_conditional_fp_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_selectors</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Selector</span><span class="p">],</span> <span class="n">parent_node</span> <span class="p">:</span> <span class="n">FPTreeNode</span><span class="p">,</span> <span class="n">fixed_tp</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fixed_fp</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private method to insert a list of selectors from a parent node.</span>
<span class="sd">        </span>
<span class="sd">        :param list_of_selectors: the list of selectors which is inserted in the conditional FPTree. IMPORTANT: we assume that the list of selectors only contains selectors.</span>
<span class="sd">        :param parent_node: the parent node from which to start the insertion.</span>
<span class="sd">        :param fixed_tp: the fixed number of true positives tp which is used in the insertions and in the increments.</span>
<span class="sd">        :param fixed_fp: the fixed number of false positives fp which is used in the insertions and in the increments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">parent_node</span>
        <span class="k">for</span> <span class="n">selector</span> <span class="ow">in</span> <span class="n">list_of_selectors</span><span class="p">:</span>
            <span class="c1"># Get the child node with the current selector or None if it does not exist.</span>
            <span class="n">child_node_with_this_selector</span> <span class="o">=</span> <span class="n">current_parent_node</span><span class="o">.</span><span class="n">get_child_by_selector</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
            <span class="c1"># Check if the node exists or not and if the parameter &#39;target_match&#39; is True or False.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">child_node_with_this_selector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Increase the true positives tp and the false positives fp in the node.</span>
                <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">counters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">fixed_tp</span>
                <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fixed_fp</span>
                <span class="c1"># Increase the total number of true positives tp and the total number of false positives fp in the header table.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">fixed_tp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fixed_fp</span>
                <span class="c1"># Go down in the tree (the current node will be the current parent node in the next iteration).</span>
                <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">child_node_with_this_selector</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">child_node_with_this_selector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create a new FPTree Node.</span>
                <span class="n">new_fptreenode</span> <span class="o">=</span> <span class="n">FPTreeNode</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="p">[</span><span class="n">fixed_tp</span><span class="p">,</span> <span class="n">fixed_fp</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># Add it as a child of the current parent node.</span>
                <span class="n">current_parent_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">new_fptreenode</span><span class="p">)</span>
                <span class="c1"># Check if the current selector is in the header table.</span>
                <span class="k">if</span> <span class="n">selector</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">:</span>
                    <span class="c1"># If it is in the header table, add the new node at the end of the horizontal list and increase the summation of tp and fp in the header table.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">_node_link</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fptreenode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">fixed_tp</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fixed_fp</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># If not, create the entry and add it.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header_table</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">fixed_tp</span><span class="p">,</span> <span class="n">fixed_fp</span><span class="p">],</span> <span class="n">new_fptreenode</span><span class="p">,</span> <span class="n">new_fptreenode</span> <span class="p">]</span>
                <span class="c1"># Go down in the tree (the current node will be the current parent node in the next iteration).</span>
                <span class="n">current_parent_node</span> <span class="o">=</span> <span class="n">new_fptreenode</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Antonio López Martínez-Carrasco.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>